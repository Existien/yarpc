/* Generated by YARPC
 * Version:  {{version}}
 * Definition:
 *   File: {{ object.definitionPath }}
 *   Object: {{ object.name }}
 *   Template: qt6/service_source.j2
 */
{% import "dbus/common.j2" as dbus %}
{% import "qt6/common.j2" as qt6 %}
#include "{{ target.className }}.hpp"

using namespace {{ qt6.namespace(output) }};

{{ target.className }}::{{ target.className }}(QObject* parent)
: QObject(parent) {
    m_adaptor = new {{ target.className }}Adaptor(this);
}

{{ target.className }}Adaptor::{{ target.className }}Adaptor(QObject* parent) : QDBusAbstractAdaptor(parent) {

}

void {{ target.className }}::connect(){
    if (m_connection != nullptr) {
        return;
    }
    m_connection = std::make_unique<QDBusConnection>(QDBusConnection::connectToBus(QDBusConnection::SessionBus, "{{ target.busName }}"));
    bool success = m_connection->isConnected();
    if (success) {
        success = success && m_connection->registerService("{{ target.busName }}");
        success = success && m_connection->registerObject(
            "{{ target.objectPath }}",
            "{{ target.interfaceName }}",
            this
        );
        if (!success) {
            m_connection->disconnectFromBus("{{ target.busName }}");
        }
    }
    if (!success) {
        m_connection = nullptr;
    }
    emit connectedChanged();
}
void {{ target.className }}::disconnect(){
    if (m_connection == nullptr) {
        return;
    }
    m_connection->disconnectFromBus("{{ target.busName }}");
    m_connection = nullptr;
    emit connectedChanged();
}

bool {{ target.className }}::getConnected() const {
    return m_connection != nullptr;
}

{% for member in object.members %}
{% if member.kind == 'signal' %}
void {{ target.className }}::Emit{{ member.name }}(){
    emit m_adaptor->{{ member.name }}();
}
{% endif %}
{% if member.kind == 'method' %}
void {{ target.className }}Adaptor::{{ member.name }}(const QDBusMessage &message){
    auto iface = dynamic_cast<{{ target.className }}*>(parent());
    if (iface != nullptr) {
        message.setDelayedReply(true);
        iface->handle{{ member.name }}Called(message);
    }
}

{{ member.name }}PendingReply::{{ member.name }}PendingReply(QDBusMessage call, QObject *parent) : QObject(parent) {
    m_call = call;
    m_args = {{ member.name }}Args{};
}

{{ member.name }}Args* {{ member.name }}PendingReply::args() {
    return &m_args;
}

void {{ member.name }}PendingReply::sendReply() {
    auto reply = m_call.createReply();
    auto iface = dynamic_cast<{{ target.className }}*>(parent());
    if (iface != nullptr) {
        iface->callFinished(reply);
    }
    deleteLater();
}

void {{ member.name }}PendingReply::sendError(const QString& name, const QString& message) {
    auto error_reply = m_call.createErrorReply(name, message);
    auto iface = dynamic_cast<{{ target.className }}*>(parent());
    if (iface != nullptr) {
        iface->callFinished(error_reply);
    }
    deleteLater();
}

void {{ member.name }}PendingReply::sendError(const DBusError &error) {
    auto error_reply = m_call.createErrorReply(error);
    auto iface = dynamic_cast<{{ target.className }}*>(parent());
    if (iface != nullptr) {
        iface->callFinished(error_reply);
    }
    deleteLater();
}

void {{ target.className }}::handle{{ member.name }}Called(QDBusMessage call) {
    auto reply = new {{ member.name }}PendingReply(call, this);
    emit {{ member.name|camel_case }}Called(reply);
}
{% endif %}
{% endfor %}

void {{ target.className }}::callFinished(const QDBusMessage &reply)
{
    m_connection->send(reply);
}
