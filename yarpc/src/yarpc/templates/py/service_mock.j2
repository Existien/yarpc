# Generated by YARPC
# Version:  {{version}}
# Spec:
#   File: {{ object.specPath }}
#   Object: {{ object.name }}
#   Template: {{ target.template }}

from dbus_next.service import (
    ServiceInterface, method, dbus_property, signal
)
from dbus_next.constants import PropertyAccess
from dbus_next import Variant, DBusError
from unittest.mock import AsyncMock
from copy import deepcopy
import asyncio

class {{ target.className }}(ServiceInterface):
    """
    Mock service implementation of the {{ object.name }} D-Bus interface.

    The AsyncMock instance can be accessed via the `mock` attribute.
    All method calls will be forwarded to the mock using keyword arguments.
    E.g.
    `await service.Foo('bar')`
    might result in the following await of the mock:
    `await service.mock.Foo(msg='bar')`
    {% if object.members|selectattr('kind', 'equalto', 'property')|list|count > 0 %}

    Setting properties will trigger a on_<property>_changed call to the mock with
    the new value and a dictionary with the current properties as arguments. The mock is expected to return
    an updated dictionary of properties.

    Per default, the mock is configured to just return the updated value.

    Args:
        {% for member in object.members|selectattr('kind', 'equalto', 'property') %}
        {{ member.name }} ({{ (member.type|find_type(output.objects)).py }}): {{ member.docs }}
        {% endfor %}
    {% endif %}
    """

    def __init__(
        self,
        {% for member in object.members|selectattr('kind', 'equalto', 'property') %}
        {{ member.name }}: {{ (member.type|find_type(output.objects)).py }},
        {% endfor %}
    ):
        super().__init__("{{ target.interfaceName }}")
        self.mock = AsyncMock()
        self.object_path = "{{ target.objectPath }}"

        {% for member in object.members|selectattr('kind', 'equalto', 'method') %}
        self.mock.{{ member.name }}.return_value = None
        {% endfor %}

        self._properties = {}
        {% for member in object.members|selectattr('kind', 'equalto', 'property') %}
        {% set type = member.type|find_type(output.objects) %}
        self._properties["{{ member.name }}"] = {{ member.name }}
        self._{{ member.name }}_change_handler = {{ target.className }}._default_{{ member.name }}_change_handler
        self.mock.on_{{ member.name }}_changed = AsyncMock(wraps=self._{{ member.name }}_change_handler)
        {% endfor %}

    async def _await_mock_method(self, method, local_variables):
        kwargs = dict(filter(lambda kv: kv[0] != 'self', local_variables.items()))
        return await getattr(self.mock, method)(**kwargs)
{% for member in object.members %}

{% if member.kind == 'signal' %}
    @signal()
    def {{ member.name }}(
        self,
        {% for arg in member.args %}
        {{ arg.name }}: {{ (arg.type|find_type(output.objects)).py }},
        {% endfor %}
    ) ->{{ ' ' }}
    {%- if member.args|count > 0 %}'{% for arg in member.args %}{{ (arg.type|find_type(output.objects)).dbus }}{% endfor %}'{% else %}None{% endif %}:
        """
        {{ member.docs }}
        {% if member.args|count > 0 %}

        Args:
        {% for arg in member.args %}
            {{ arg.name }} ({{ (arg.type|find_type(output.objects)).py }}): {{ arg.docs }}
        {% endfor %}
        {% endif %}
        """
        {% if member.args|count > 1 %}
        return [
            {% for arg in member.args %}
            {{ arg.name }},
            {% endfor %}
        ]
        {% elif member.args|count == 1 %}
        return {{ member.args[0].name }}
        {% endif %}
{% endif %}
{% if member.kind == 'method' %}
    @method()
    async def {{ member.name }}(
        self,
        {% for arg in member.args %}
        {{ arg.name }}: '{{ (arg.type|find_type(output.objects)).dbus }}',
        {% endfor %}
    ) ->{{ ' ' }}
    {%- if member.returns %}'{{ (member.returns.type|find_type(output.objects)).dbus }}'{% else %}None{% endif %}:
        """
        {{ member.docs }}
        {% if member.args|count > 0 %}

        Args:
        {% for arg in member.args %}
            {{ arg.name }} ({{ (arg.type|find_type(output.objects)).py }}): {{ arg.docs }}
        {% endfor %}
        {% endif %}
        {% if member.returns %}

        Returns:
            {{ (member.returns.type|find_type(output.objects)).py }}: {{ member.returns.docs }}
        {% endif %}
        """
        return await self._await_mock_method("{{ member.name }}", locals())
{%- endif -%}
{% if member.kind == 'property' %}
{% if member.readonly %}
{% set access = 'PropertyAccess.READ' %}
{% else %}
{% set access = 'PropertyAccess.READWRITE' %}
{% endif %}

    @dbus_property(access={{ access }})
    def {{ member.name }}(self) -> '{{ (member.type|find_type(output.objects)).dbus }}':
        return self._properties["{{ member.name }}"]

    def on_{{ member.name }}_changed(self, handler) -> None:
        """
        Set handler for property changes due to {{ member.name }} changes

        The handler takes the new {{ member.name}} value and a dictionary of the current properties
        and returns a dictionary with the current property values, or just the changed ones

        Args:
            handler(Callable[[{{ (member.type|find_type(output.objects)).py }}, dict], Awaitable[dict]]): the properties change handler

        Returns:
            dict: the changed properties
        """
        self._{{ member.name }}_change_handler = handler
        self.mock.on_{{ member.name }}_changed = AsyncMock(wraps=self._{{ member.name }}_change_handler)

    async def _default_{{ member.name }}_change_handler(value: {{ (member.type|find_type(output.objects)).py }}, _: dict) -> dict:
        return { "{{ member.name }}": value }

    async def set_{{ member.name }}(self, value: {{ (member.type|find_type(output.objects)).py }}):
        properties_working_copy = deepcopy(self._properties)
        changed_properties = await self.mock.on_{{ member.name }}_changed(value, properties_working_copy)
        properties_working_copy.update(changed_properties)
        for key in self._properties.keys():
            if key not in properties_working_copy:
                continue
            if properties_working_copy[key] == self._properties[key]:
                del properties_working_copy[key]
            else:
                self._properties[key] = properties_working_copy[key]
        if properties_working_copy:
            self.emit_properties_changed(properties_working_copy)
{% if not member.readonly %}

    @{{ member.name }}.setter
    async def {{ member.name }}(self, value: '{{ (member.type|find_type(output.objects)).dbus }}'):
        await self.set_{{ member.name }}(value)
{%- endif -%}
{% endif %}
{% endfor %}
