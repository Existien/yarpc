# Generated by YARPC
# Version:  {{version}}
# Spec:
#   File: {{ object.specPath }}
#   Object: {{ object.name }}

from dbus_next.aio import MessageBus
from dbus_next.service import (
    ServiceInterface, method, dbus_property, signal
)
from dbus_next import Variant, DBusError

import asyncio

class {{ object.name }}ServiceInterface(ServiceInterface):
    """
    {{ object.docs }}
    """

    def __init__(self):
        super().__init__("{{ target.interfaceName }}")
        {% for member in object.members %}
        {% if member['kind'] == 'method' %}
        self._{{ member['name'] }}_handler = None
        {% endif %}
        {% endfor %}

    async def run(self):
        """
        Initializes the D-Bus connection and waits until it is closed
        """
        bus = await MessageBus().connect()
        bus.export("{{ target.objectPath }}", self)
        await bus.request_name("{{ target.busName }}")
        await bus.wait_for_disconnect()
{% for member in object.members %}

{% if member.kind == 'signal' %}
    @signal()
    def {{ member.name }}(self) -> None:
        """
        {{ member.docs }}
        """
        return
{% endif %}
{% if member.kind == 'method' %}
{% set handler = 'self._'+member.name+'_handler' %}

    def on_{{ member.name }}(self, handler) -> None:
        """
        Set handler for {{ member.name }} method

        Args:
            handler (Callable[[], Awaitable[None]]): the method handler
        """
        {{ handler }} = handler

    @method()
    async def {{ member.name }}(self) -> None:
        """
        {{ member.docs }}
        """
        if {{ handler }} is None:
            raise NotImplementedError()

        return await {{ handler }}()
{% endif %}
{% endfor %}