# Generated by YARPC
# Version:  {{version}}
# Spec:
#   File: {{ object.specPath }}
#   Object: {{ object.name }}
#   Template: py/service.j2
{% import "dbus_common.j2" as dbus %}
{% import "py/common.j2" as py %}

from typing import Protocol, Sequence
from dbus_next.service import (
    ServiceInterface, method, dbus_property, signal
)
from dbus_next.constants import PropertyAccess
from dbus_next import Variant, DBusError
from copy import deepcopy
{% for object in output.objects|selectattr('kind', 'equalto', 'struct') %}
from .{{ object.name|snake_case }} import {{ object.name }}
{% endfor %}

{% if object.members|selectattr('kind', 'equalto', 'property')|list|count > 0 %}

class Provides{{ target.className }}Properties(Protocol):
    """Protocol for property providers of {{ target.className }}
    """
    {% for member in object.members|selectattr('kind', 'equalto', 'property') %}

    async def get_{{ member.name }}(self) -> {{ py.type(member.type, output.objects) }}:
        """Getter for {{ member.name }} property

        Returns:
            {{ py.type(member.type, output.objects) }}: the current value
        """
        ...

    async def set_{{ member.name }}(self, value: {{ py.type(member.type, output.objects) }}) -> dict:
        """Setter for {{ member.name }} property

        Args:
            value ({{ py.type(member.type, output.objects) }}): the new value

        Returns:
            dict: dictionary of the changed properties, empty if None changed
        """
        ...
    {% endfor %}


class {{ target.className }}Properties:
    """Manages the state of the properties for {{ target.className }}

    Args:
        {% for member in object.members|selectattr('kind', 'equalto', 'property') %}
        {{ member.name }} ({{ py.type(member.type, output.objects) }}): {{ member.docs|indent(12) }}
        {% endfor %}
    """

    def __init__(
        self,
        {% for member in object.members|selectattr('kind', 'equalto', 'property') %}
        {{ member.name }}: {{ py.type(member.type, output.objects) }},
        {% endfor %}
    ):
        self._properties = {
        {% for member in object.members|selectattr('kind', 'equalto', 'property') %}
        {% set type = member.type|find_type(output.objects) %}
            "{{ member.name }}": {{ member.name }},
        {% endfor %}
        }
    {% for member in object.members|selectattr('kind', 'equalto', 'property') %}

    async def get_{{ member.name }}(self) -> {{ py.type(member.type, output.objects) }}:
        """Getter for {{ member.name }} property

        Returns:
            {{ py.type(member.type, output.objects) }}: the current value
        """
        return self._properties["{{ member.name }}"]

    async def set_{{ member.name }}(self, value: {{ py.type(member.type, output.objects) }}) -> dict:
        """Setter for {{ member.name }} property

        Args:
            value ({{ py.type(member.type, output.objects) }}): the new value

        Returns:
            dict: dictionary of the changed properties, empty if None changed
        """
        if value == self._properties["{{ member.name }}"]:
            return {}
        self._properties["{{ member.name }}"] = value
        return {"{{ member.name }}": value}
    {% endfor %}
{% endif %}


class _Interface(ServiceInterface):
    """
    D-Bus interface implementation for {{ object.name }}

    Args:
        wrapper({{ target.className }}): Wrapper responsible for (un-)marhsalling D-Bus types
    """

    def __init__(self, wrapper):
        super().__init__("{{ target.interfaceName }}")
        self.object_path = "{{ target.objectPath }}"
        self._wrapper = wrapper
{% for member in object.members %}

{% if member.kind == 'signal' %}
    @signal()
    def {{ member.name }}(
        self,
        {% for arg in member.args %}
        {{ arg.name }}: '{{ dbus.type(arg.type, output.objects) }}',
        {% endfor %}
    ) ->{{ ' ' }}
    {%- if member.args|count > 0 %}'{% for arg in member.args %}{{ dbus.type(arg.type, output.objects) }}{% endfor %}'{% else %}None{% endif %}:
        {% if member.args|count > 1 %}
        return [
            {% for arg in member.args %}
            {{ arg.name }},
            {% endfor %}
        ]
        {% elif member.args|count == 1 %}
        return {{ member.args[0].name }}
        {% else %}
        return None
        {% endif %}
{%- endif -%}
{% if member.kind == 'method' %}
{% set handler = 'self._'+member.name+'_handler' %}
    @method()
    async def {{ member.name }}(
        self,
        {% for arg in member.args %}
        {{ arg.name }}: '{{ dbus.type(arg.type, output.objects) }}',
        {% endfor %}
    ) ->{{ ' ' }}
    {%- if member.returns %}'{{ dbus.type(member.returns.type, output.objects) }}'{% else %}None{% endif %}:
        {{''}}{% if member.returns %}raw_return = {% endif %}await self._wrapper.{{ member.name }}(
            {% for arg in member.args %}
            {{ py.from_dbus(arg.name, arg.type, output.objects) }},
            {% endfor %}
        )
        {% if member.returns %}
        return {{ py.to_dbus('raw_return', member.returns.type, output.objects)|indent(8) }}
        {% else %}
        return None
        {% endif %}
{%- endif -%}
{% if member.kind == 'property' %}
{% if member.readonly %}
{% set access = 'PropertyAccess.READ' %}
{% else %}
{% set access = 'PropertyAccess.READWRITE' %}
{% endif %}
    @dbus_property(access={{ access }})
    async def {{ member.name }}(self) -> '{{ dbus.type(member.type, output.objects) }}':
        unmarshalled = await self._wrapper.get_{{ member.name}}()
        return {{ py.to_dbus('unmarshalled', member.type, output.objects)|indent(8) }}
{% if not member.readonly %}

    @{{ member.name }}.setter
    async def {{ member.name }}(self, value: '{{ dbus.type(member.type, output.objects) }}'):
        unmarshalled = {{ py.from_dbus('value', member.type, output.objects) }}
        await self._wrapper.set_{{ member.name }}(unmarshalled)
{% endif %}
{% endif %}
{% endfor %}


class {{ target.className }}():
    """
    {{ object.docs|indent(4) }}
    {% if object.members|selectattr('kind', 'equalto', 'property')|list|count > 0 %}

    Args:
        property_provider (Provides{{ target.className }}Properties): provider for interface properties
    {% endif %}
    """

    def __init__(
        self,
        {% if object.members|selectattr('kind', 'equalto', 'property')|list|count > 0 %}
        property_provider: Provides{{ target.className }}Properties,
        {% endif %}
    ):
        self.interface = _Interface(self)
        self.name = self.interface.name
        self.object_path = self.interface.object_path

        {% for member in object.members|selectattr('kind', 'equalto', 'method') %}
        self._{{ member.name }}_handler = None
        {% endfor %}
        {% if object.members|selectattr('kind', 'equalto', 'property')|list|count > 0 %}
        self._properties = property_provider
        {% endif %}

    def emit_properties_changed(self, changed_properties: dict) -> None:
        """Informs clients about changed properties

        Args:
            changed_properties (dict): A dictionary containing all changed properties with their new values
        """
        if not changed_properties: return

        def marshal(data):
            if isinstance(data, dict):
                for key in data.keys():
                    data[key] = marshal(data[key])
                return data
            elif isinstance(data, list):
                for i in range(0, len(data)):
                    data[i] = marshal(data[i])
                return data
            elif hasattr(data, 'to_dbus'):
                return data.to_dbus()
            else:
                return data
        marshalled = marshal(deepcopy(changed_properties))
        self.interface.emit_properties_changed(marshalled)
{% for member in object.members %}

{% if member.kind == 'signal' %}
    def {{ member.name }}(
        self,
        {% for arg in member.args %}
        {{ arg.name }}: {{ py.type(arg.type, output.objects) }},
        {% endfor %}
    ) -> None:
        """
        {{ member.docs|indent(8) }}
        {% if member.args|count > 0 %}

        Args:
        {% for arg in member.args %}
            {{ arg.name }} ({{ py.type(arg.type, output.objects) }}): {{ arg.docs|indent(16) }}
        {% endfor %}
        {% endif %}
        """
        self.interface.{{ member.name }}(
            {% for arg in member.args %}
            {{ py.to_dbus(arg.name, arg.type, output.objects)|indent(12) }},
            {% endfor %}
        )
{% endif %}
{% if member.kind == 'method' %}
{% set handler = 'self._'+member.name+'_handler' %}
    def on_{{ member.name }}(self, handler) -> None:
        """
        Set handler for {{ member.name }} method

        Args:
            handler (Callable[[
                {%- for i in range(0,member.args|count) -%}
                {{ py.type(member.args[i].type, output.objects) }}
                {%- if i < member.args|count - 1 -%}
                {{', '}}
                {%- endif -%}
                {%- endfor -%}
                ], Awaitable[
                {%- if member.returns -%}
                {{ py.type(member.returns.type, output.objects) }}
                {%- else -%}
                None
                {%- endif -%}
                ]]): the method handler
        """
        {{ handler }} = handler

    async def {{ member.name }}(
        self,
        {% for arg in member.args %}
        {{ arg.name }}: {{ py.type(arg.type, output.objects) }},
        {% endfor %}
    ) ->{{ ' ' }}
    {%- if member.returns %}{{ py.type(member.returns.type, output.objects) }}{% else %}None{% endif %}:
        """
        {{ member.docs|indent(8) }}
        {% if member.args|count > 0 %}

        Args:
        {% for arg in member.args %}
            {{ arg.name }} ({{ py.type(arg.type, output.objects) }}): {{ arg.docs|indent(16) }}
        {% endfor %}
        {% endif %}
        {% if member.returns %}

        Returns:
            {{ py.type(member.returns.type, output.objects) }}: {{ member.returns.docs|indent(16) }}
        {% endif %}
        """
        if {{ handler }} is None:
            raise NotImplementedError()

        return await {{ handler }}(
            {% for arg in member.args %}
            {{ arg.name }},
            {% endfor %}
        )
{% endif %}
{% if member.kind == 'property' %}
{% if member.readonly %}
{% set access = 'PropertyAccess.READ' %}
{% else %}
{% set access = 'PropertyAccess.READWRITE' %}
{% endif %}
    async def get_{{ member.name }}(self) -> {{ py.type(member.type, output.objects) }}:
        """Getter for property {{ member.name }}

        {{ member.docs|indent(8) }}

        Returns:
            {{ py.type(member.type, output.objects) }}: the current value
        """
        return await self._properties.get_{{ member.name }}()

    async def set_{{ member.name }}(self, value: {{ py.type(member.type, output.objects) }}):
        """Setter for property {{ member.name }}

        {{ member.docs|indent(8) }}

        Args:
            value ({{ py.type(member.type, output.objects) }}): the new value
        """
        changed_properties = await self._properties.set_{{ member.name }}(value)

        self.emit_properties_changed(changed_properties)
{% endif %}
{% endfor %}