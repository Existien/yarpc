/* Generated by YARPC
 * Version:  0.1.0
 * Definition:
 *   File: /workspace/tests/definitions/04.1_arrays.yml
 *   Object: Arrays
 *   Template: qt6/service_source.j2
 */
#include "ArraysInterface.hpp"
#include "ArraysInterfaceAdaptor.hpp"
#include "Connection.hpp"
#include "types.hpp"

using namespace gen::arrays;

ArraysInterface::ArraysInterface(QObject* parent)
: QObject(parent) {
    registerMetaTypes();
    StructArray::registerMetaTypes();
    SimonsArray::registerMetaTypes();
    QObject::connect(
        &Connection::instance(),
        &Connection::connectedChanged,
        this,
        &ArraysInterface::connectedChanged
    );
    QObject::connect(
        &Connection::instance(),
        &Connection::registrationChanged,
        this,
        &ArraysInterface::connectedChanged
    );
}

void ArraysInterface::connect() {
    Connection::instance().registerArrays(this);
}

void ArraysInterface::disconnect() {
    Connection::instance().unregisterArrays();
}

void ArraysInterface::finishCall(const QDBusMessage &reply)
{
    Connection::instance().send(reply);
}

bool ArraysInterface::getConnected() const {
    return (
        Connection::instance().getConnected()
        && Connection::instance().isArraysRegistered()
    );
}

ArrayMethodPendingReply::ArrayMethodPendingReply(QDBusMessage call, QObject *parent) : QObject(parent) {
    m_call = call;
    QList<QList<uint>> arg_0;
    {
        auto marshalled = m_call.arguments()[0].value<QDBusArgument>();
        marshalled >> arg_0;
    }
    m_args = ArrayMethodArgs{
        .numbers = arg_0,
    };
}

ArrayMethodArgs ArrayMethodPendingReply::args() {
    return m_args;
}

void ArrayMethodPendingReply::sendReply(
    QVariant reply
) {
    QList<QList<double>> unmarshalled;
    for (auto& item_0 : reply.value<QVariantList>()) {
        QList<double> o_0;
        for (auto& item_1 : item_0.value<QVariantList>()) {
            double o_1;
            o_1 = item_1.value<double>();

            o_0.push_back(o_1);
        }

        unmarshalled.push_back(o_0);
    }

    sendReply(unmarshalled);
}

void ArrayMethodPendingReply::sendReply(
    const QList<QList<double>> &reply
) {
    auto dbusReply = m_call.createReply(QVariant::fromValue(reply));
    auto iface = dynamic_cast<ArraysInterface*>(parent());
    if (iface != nullptr) {
        iface->finishCall(dbusReply);
    }
    deleteLater();
}

void ArrayMethodPendingReply::sendError(const QString& name, const QString& message) {
    auto error_reply = m_call.createErrorReply(name, message);
    auto iface = dynamic_cast<ArraysInterface*>(parent());
    if (iface != nullptr) {
        iface->finishCall(error_reply);
    }
    deleteLater();
}

void ArrayMethodPendingReply::sendError(const DBusError &error) {
    auto error_reply = m_call.createErrorReply(error);
    auto iface = dynamic_cast<ArraysInterface*>(parent());
    if (iface != nullptr) {
        iface->finishCall(error_reply);
    }
    deleteLater();
}

void ArraysInterface::handleArrayMethodCalled(QDBusMessage call) {
    auto reply = new ArrayMethodPendingReply(call, this);
    emit arrayMethodCalled(reply);
}

void ArraysInterface::EmitArraySignal(
    QList<QList<double>> numbers
) {
    if (Connection::instance().Arrays() != nullptr ) {
        emit Connection::instance().Arrays()->ArraySignal(
            numbers
        );
    }
}

void ArraysInterface::EmitArraySignal(
    QVariant numbers
) {
    QList<QList<double>> arg_0;
    for (auto& item_0 : numbers.value<QVariantList>()) {
        QList<double> o_0;
        for (auto& item_1 : item_0.value<QVariantList>()) {
            double o_1;
            o_1 = item_1.value<double>();

            o_0.push_back(o_1);
        }

        arg_0.push_back(o_0);
    }

    EmitArraySignal(
        arg_0
    );
}

QList<QList<QString>> ArraysInterface::getArrayProperty() const {
    return m_ArrayProperty;
}

void ArraysInterface::setArrayProperty(const QList<QList<QString>> &value ) {
    m_ArrayProperty = value;
    emit arrayPropertyChanged();
    if (Connection::instance().Arrays() != nullptr ) {
        QVariantMap changedProps;
        changedProps.insert("ArrayProperty", QVariant::fromValue(value));
        emitPropertiesChangedSignal(changedProps);
    }
}

QVariant ArraysInterface::getVariantArrayProperty() const {
    auto unmarshalled = getArrayProperty();
    QVariant marshalled;
    QList<QVariant> list_0;
    for (auto& item_0 : unmarshalled) {
        QVariant o_0;
        QList<QVariant> list_1;
        for (auto& item_1 : item_0) {
            QVariant o_1;
            o_1 = QVariant::fromValue(item_1);

            list_1.push_back(o_1);
        }
        o_0 = QVariant::fromValue(list_1);

        list_0.push_back(o_0);
    }
    marshalled = QVariant::fromValue(list_0);

    return marshalled;
}

void ArraysInterface::setVariantArrayProperty(QVariant value ) {
    QList<QList<QString>> unmarshalled;
    for (auto& item_0 : value.value<QVariantList>()) {
        QList<QString> o_0;
        for (auto& item_1 : item_0.value<QVariantList>()) {
            QString o_1;
            o_1 = item_1.value<QString>();

            o_0.push_back(o_1);
        }

        unmarshalled.push_back(o_0);
    }

    setArrayProperty(unmarshalled);
}


void ArraysInterface::emitPropertiesChangedSignal(const QVariantMap &changedProps) {
    auto signal = QDBusMessage::createSignal(
        "/com/yarpc/testservice/arrays",
        "org.freedesktop.DBus.Properties",
        "PropertiesChanged"
    );
    signal << "com.yarpc.testservice.arrays";
    signal << changedProps;
    signal << QStringList{};
    Connection::instance().send(signal);
}