# Generated by YARPC
# Version:  0.1.0+editable
# Spec:
#   File: /workspace/tests/specs/05.4_dictionaries_keys.yml
#   Object: DictKeys
#   Template: py/service.j2

from typing import Protocol, Sequence, Mapping
from dbus_next.service import (
    ServiceInterface, method, dbus_property, signal
)
from dbus_next.constants import PropertyAccess
from dbus_next import Variant, DBusError
from copy import deepcopy
from .struct_dict import StructDict
from .simons_dict import SimonsDict



class _Interface(ServiceInterface):
    """
    D-Bus interface implementation for DictKeys

    Args:
        wrapper(DictKeysInterface): Wrapper responsible for (un-)marhsalling D-Bus types
    """

    def __init__(self, wrapper):
        super().__init__("com.yarpc.testservice.dictKeys")
        self.object_path = "/com/yarpc/testservice"
        self._wrapper = wrapper

    @signal()
    def Uint8Signal(
        self,
        value: 'a{ys}',
    ) -> 'a{ys}':
        return value

    @signal()
    def BoolSignal(
        self,
        value: 'a{bs}',
    ) -> 'a{bs}':
        return value

    @signal()
    def Int16Signal(
        self,
        value: 'a{ns}',
    ) -> 'a{ns}':
        return value

    @signal()
    def Uint16Signal(
        self,
        value: 'a{qs}',
    ) -> 'a{qs}':
        return value

    @signal()
    def Int32Signal(
        self,
        value: 'a{is}',
    ) -> 'a{is}':
        return value

    @signal()
    def Uint32Signal(
        self,
        value: 'a{us}',
    ) -> 'a{us}':
        return value

    @signal()
    def Int64Signal(
        self,
        value: 'a{xs}',
    ) -> 'a{xs}':
        return value

    @signal()
    def Uint64Signal(
        self,
        value: 'a{ts}',
    ) -> 'a{ts}':
        return value

    @signal()
    def DoubleSignal(
        self,
        value: 'a{ds}',
    ) -> 'a{ds}':
        return value

    @signal()
    def StringSignal(
        self,
        value: 'a{ss}',
    ) -> 'a{ss}':
        return value

    @method()
    async def Uint8Method(
        self,
        value: 'a{ys}',
    ) -> 'a{ys}':
        raw_return = await self._wrapper.Uint8Method(
            { k0: v0 for k0, v0 in value.items() },
        )
        return { k0: v0 for k0, v0 in raw_return.items() }

    @method()
    async def BoolMethod(
        self,
        value: 'a{bs}',
    ) -> 'a{bs}':
        raw_return = await self._wrapper.BoolMethod(
            { k0: v0 for k0, v0 in value.items() },
        )
        return { k0: v0 for k0, v0 in raw_return.items() }

    @method()
    async def Int16Method(
        self,
        value: 'a{ns}',
    ) -> 'a{ns}':
        raw_return = await self._wrapper.Int16Method(
            { k0: v0 for k0, v0 in value.items() },
        )
        return { k0: v0 for k0, v0 in raw_return.items() }

    @method()
    async def Uint16Method(
        self,
        value: 'a{qs}',
    ) -> 'a{qs}':
        raw_return = await self._wrapper.Uint16Method(
            { k0: v0 for k0, v0 in value.items() },
        )
        return { k0: v0 for k0, v0 in raw_return.items() }

    @method()
    async def Int32Method(
        self,
        value: 'a{is}',
    ) -> 'a{is}':
        raw_return = await self._wrapper.Int32Method(
            { k0: v0 for k0, v0 in value.items() },
        )
        return { k0: v0 for k0, v0 in raw_return.items() }

    @method()
    async def Uint32Method(
        self,
        value: 'a{us}',
    ) -> 'a{us}':
        raw_return = await self._wrapper.Uint32Method(
            { k0: v0 for k0, v0 in value.items() },
        )
        return { k0: v0 for k0, v0 in raw_return.items() }

    @method()
    async def Int64Method(
        self,
        value: 'a{xs}',
    ) -> 'a{xs}':
        raw_return = await self._wrapper.Int64Method(
            { k0: v0 for k0, v0 in value.items() },
        )
        return { k0: v0 for k0, v0 in raw_return.items() }

    @method()
    async def Uint64Method(
        self,
        value: 'a{ts}',
    ) -> 'a{ts}':
        raw_return = await self._wrapper.Uint64Method(
            { k0: v0 for k0, v0 in value.items() },
        )
        return { k0: v0 for k0, v0 in raw_return.items() }

    @method()
    async def DoubleMethod(
        self,
        value: 'a{ds}',
    ) -> 'a{ds}':
        raw_return = await self._wrapper.DoubleMethod(
            { k0: v0 for k0, v0 in value.items() },
        )
        return { k0: v0 for k0, v0 in raw_return.items() }

    @method()
    async def StringMethod(
        self,
        value: 'a{ss}',
    ) -> 'a{ss}':
        raw_return = await self._wrapper.StringMethod(
            { k0: v0 for k0, v0 in value.items() },
        )
        return { k0: v0 for k0, v0 in raw_return.items() }


class DictKeysInterface():
    """
    A interface using dictionaries with different keys
    """

    def __init__(
        self,
    ):
        self.interface = _Interface(self)
        self.name = self.interface.name
        self.object_path = self.interface.object_path

        self._Uint8Method_handler = None
        self._BoolMethod_handler = None
        self._Int16Method_handler = None
        self._Uint16Method_handler = None
        self._Int32Method_handler = None
        self._Uint32Method_handler = None
        self._Int64Method_handler = None
        self._Uint64Method_handler = None
        self._DoubleMethod_handler = None
        self._StringMethod_handler = None

    def emit_properties_changed(self, changed_properties: dict) -> None:
        """Informs clients about changed properties

        Args:
            changed_properties (dict): A dictionary containing all changed properties with their new values
        """
        if not changed_properties: return

        def marshal(data):
            if isinstance(data, dict):
                for key in data.keys():
                    data[key] = marshal(data[key])
                return data
            elif isinstance(data, list):
                for i in range(0, len(data)):
                    data[i] = marshal(data[i])
                return data
            elif hasattr(data, 'to_dbus'):
                return data.to_dbus()
            else:
                return data
        marshalled = marshal(deepcopy(changed_properties))
        self.interface.emit_properties_changed(marshalled)

    def Uint8Signal(
        self,
        value: Mapping[int, str],
    ) -> None:
        """
        a signal

        Args:
            value (Mapping[int, str]): the value
        """
        self.interface.Uint8Signal(
            { k0: v0 for k0, v0 in value.items() },
        )

    def BoolSignal(
        self,
        value: Mapping[bool, str],
    ) -> None:
        """
        a signal

        Args:
            value (Mapping[bool, str]): the value
        """
        self.interface.BoolSignal(
            { k0: v0 for k0, v0 in value.items() },
        )

    def Int16Signal(
        self,
        value: Mapping[int, str],
    ) -> None:
        """
        a signal

        Args:
            value (Mapping[int, str]): the value
        """
        self.interface.Int16Signal(
            { k0: v0 for k0, v0 in value.items() },
        )

    def Uint16Signal(
        self,
        value: Mapping[int, str],
    ) -> None:
        """
        a signal

        Args:
            value (Mapping[int, str]): the value
        """
        self.interface.Uint16Signal(
            { k0: v0 for k0, v0 in value.items() },
        )

    def Int32Signal(
        self,
        value: Mapping[int, str],
    ) -> None:
        """
        a signal

        Args:
            value (Mapping[int, str]): the value
        """
        self.interface.Int32Signal(
            { k0: v0 for k0, v0 in value.items() },
        )

    def Uint32Signal(
        self,
        value: Mapping[int, str],
    ) -> None:
        """
        a signal

        Args:
            value (Mapping[int, str]): the value
        """
        self.interface.Uint32Signal(
            { k0: v0 for k0, v0 in value.items() },
        )

    def Int64Signal(
        self,
        value: Mapping[int, str],
    ) -> None:
        """
        a signal

        Args:
            value (Mapping[int, str]): the value
        """
        self.interface.Int64Signal(
            { k0: v0 for k0, v0 in value.items() },
        )

    def Uint64Signal(
        self,
        value: Mapping[int, str],
    ) -> None:
        """
        a signal

        Args:
            value (Mapping[int, str]): the value
        """
        self.interface.Uint64Signal(
            { k0: v0 for k0, v0 in value.items() },
        )

    def DoubleSignal(
        self,
        value: Mapping[float, str],
    ) -> None:
        """
        a signal

        Args:
            value (Mapping[float, str]): the value
        """
        self.interface.DoubleSignal(
            { k0: v0 for k0, v0 in value.items() },
        )

    def StringSignal(
        self,
        value: Mapping[str, str],
    ) -> None:
        """
        a signal

        Args:
            value (Mapping[str, str]): the value
        """
        self.interface.StringSignal(
            { k0: v0 for k0, v0 in value.items() },
        )

    def on_Uint8Method(self, handler) -> None:
        """
        Set handler for Uint8Method method

        Args:
            handler (Callable[[Mapping[int, str]], Awaitable[Mapping[int, str]]]): the method handler
        """
        self._Uint8Method_handler = handler

    async def Uint8Method(
        self,
        value: Mapping[int, str],
    ) -> Mapping[int, str]:
        """
        a method

        Args:
            value (Mapping[int, str]): the value

        Returns:
            Mapping[int, str]: the return type
        """
        if self._Uint8Method_handler is None:
            raise NotImplementedError()

        return await self._Uint8Method_handler(
            value,
        )

    def on_BoolMethod(self, handler) -> None:
        """
        Set handler for BoolMethod method

        Args:
            handler (Callable[[Mapping[bool, str]], Awaitable[Mapping[bool, str]]]): the method handler
        """
        self._BoolMethod_handler = handler

    async def BoolMethod(
        self,
        value: Mapping[bool, str],
    ) -> Mapping[bool, str]:
        """
        a method

        Args:
            value (Mapping[bool, str]): the value

        Returns:
            Mapping[bool, str]: the return type
        """
        if self._BoolMethod_handler is None:
            raise NotImplementedError()

        return await self._BoolMethod_handler(
            value,
        )

    def on_Int16Method(self, handler) -> None:
        """
        Set handler for Int16Method method

        Args:
            handler (Callable[[Mapping[int, str]], Awaitable[Mapping[int, str]]]): the method handler
        """
        self._Int16Method_handler = handler

    async def Int16Method(
        self,
        value: Mapping[int, str],
    ) -> Mapping[int, str]:
        """
        a method

        Args:
            value (Mapping[int, str]): the value

        Returns:
            Mapping[int, str]: the return type
        """
        if self._Int16Method_handler is None:
            raise NotImplementedError()

        return await self._Int16Method_handler(
            value,
        )

    def on_Uint16Method(self, handler) -> None:
        """
        Set handler for Uint16Method method

        Args:
            handler (Callable[[Mapping[int, str]], Awaitable[Mapping[int, str]]]): the method handler
        """
        self._Uint16Method_handler = handler

    async def Uint16Method(
        self,
        value: Mapping[int, str],
    ) -> Mapping[int, str]:
        """
        a method

        Args:
            value (Mapping[int, str]): the value

        Returns:
            Mapping[int, str]: the return type
        """
        if self._Uint16Method_handler is None:
            raise NotImplementedError()

        return await self._Uint16Method_handler(
            value,
        )

    def on_Int32Method(self, handler) -> None:
        """
        Set handler for Int32Method method

        Args:
            handler (Callable[[Mapping[int, str]], Awaitable[Mapping[int, str]]]): the method handler
        """
        self._Int32Method_handler = handler

    async def Int32Method(
        self,
        value: Mapping[int, str],
    ) -> Mapping[int, str]:
        """
        a method

        Args:
            value (Mapping[int, str]): the value

        Returns:
            Mapping[int, str]: the return type
        """
        if self._Int32Method_handler is None:
            raise NotImplementedError()

        return await self._Int32Method_handler(
            value,
        )

    def on_Uint32Method(self, handler) -> None:
        """
        Set handler for Uint32Method method

        Args:
            handler (Callable[[Mapping[int, str]], Awaitable[Mapping[int, str]]]): the method handler
        """
        self._Uint32Method_handler = handler

    async def Uint32Method(
        self,
        value: Mapping[int, str],
    ) -> Mapping[int, str]:
        """
        a method

        Args:
            value (Mapping[int, str]): the value

        Returns:
            Mapping[int, str]: the return type
        """
        if self._Uint32Method_handler is None:
            raise NotImplementedError()

        return await self._Uint32Method_handler(
            value,
        )

    def on_Int64Method(self, handler) -> None:
        """
        Set handler for Int64Method method

        Args:
            handler (Callable[[Mapping[int, str]], Awaitable[Mapping[int, str]]]): the method handler
        """
        self._Int64Method_handler = handler

    async def Int64Method(
        self,
        value: Mapping[int, str],
    ) -> Mapping[int, str]:
        """
        a method

        Args:
            value (Mapping[int, str]): the value

        Returns:
            Mapping[int, str]: the return type
        """
        if self._Int64Method_handler is None:
            raise NotImplementedError()

        return await self._Int64Method_handler(
            value,
        )

    def on_Uint64Method(self, handler) -> None:
        """
        Set handler for Uint64Method method

        Args:
            handler (Callable[[Mapping[int, str]], Awaitable[Mapping[int, str]]]): the method handler
        """
        self._Uint64Method_handler = handler

    async def Uint64Method(
        self,
        value: Mapping[int, str],
    ) -> Mapping[int, str]:
        """
        a method

        Args:
            value (Mapping[int, str]): the value

        Returns:
            Mapping[int, str]: the return type
        """
        if self._Uint64Method_handler is None:
            raise NotImplementedError()

        return await self._Uint64Method_handler(
            value,
        )

    def on_DoubleMethod(self, handler) -> None:
        """
        Set handler for DoubleMethod method

        Args:
            handler (Callable[[Mapping[float, str]], Awaitable[Mapping[float, str]]]): the method handler
        """
        self._DoubleMethod_handler = handler

    async def DoubleMethod(
        self,
        value: Mapping[float, str],
    ) -> Mapping[float, str]:
        """
        a method

        Args:
            value (Mapping[float, str]): the value

        Returns:
            Mapping[float, str]: the return type
        """
        if self._DoubleMethod_handler is None:
            raise NotImplementedError()

        return await self._DoubleMethod_handler(
            value,
        )

    def on_StringMethod(self, handler) -> None:
        """
        Set handler for StringMethod method

        Args:
            handler (Callable[[Mapping[str, str]], Awaitable[Mapping[str, str]]]): the method handler
        """
        self._StringMethod_handler = handler

    async def StringMethod(
        self,
        value: Mapping[str, str],
    ) -> Mapping[str, str]:
        """
        a method

        Args:
            value (Mapping[str, str]): the value

        Returns:
            Mapping[str, str]: the return type
        """
        if self._StringMethod_handler is None:
            raise NotImplementedError()

        return await self._StringMethod_handler(
            value,
        )
